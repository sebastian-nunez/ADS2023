# Recursion

> Using a function that calls itself on identical, but smaller, sub-problems to solve the original problem.

## Two Tings

- **Base case:** simplest smallest sub problem
- **Recursive case:** gets you closer and closer to the base case

### Complexities

> Number of recursive calls == Maximum number of stack frames

- **Space:** Space of 1 call \* Maximum number of stack frames
- **Time:** Time of 1 call \* number of calls

```python
def recursive_function(x) {
    if x < = 1:
        print(“Base case!”)
    else:
        print(“Starting value: ”, x)
        recursive_function(x - 1)
        print(“Done with value: ”, x)
}
```

## Branching

> You can have multiple recursive calls

### Fibonnaci

```python
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1

    return fib(n - 1) + fib(n - 2)
```
