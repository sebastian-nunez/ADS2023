# Linked List

> People standing in a line and you can only interact with the person in front you

- A **Linked List** is an alternative _implementation_ of the List Abstract Data Type.
- An item in a Linked List is commonly known as a **Node**.
- Unlike arrayâ€™s where the items are held in a contiguous block of memory, linked lists nodes do not have to be.The nodes can be scattered! ðŸ¤¯
- Each node contains information about where another node is located in memory. This is called a Link
- The chaining of nodes via Links is where the data structure derives its name.

## Strategy For LinkedLists

- When modifying a list, **return the head**
- Use **temp** variables to **iterate** through a list, leaving the head where it belongs
- **Never modify existing nodeâ€™s .val values**, unless explicitly instructed to
- Watch for edge cases!
  - What if the input is empty?
  - Is your function different when the target is the first/last element, or if itâ€™s somewhere in between?
  - Does the head of the list need to change?

## Multiple Runners

- The runner technique means that you iterate through the linked list with two pointers simultaneously, with one ahead of the other.

- The fast node might be ahead by a fixed amount, or it might be hopping multiple nodes for each one node that the slow node iterates through.

- Letâ€™s consider the following problem:
  - Given an non-empty, singly LinkedList with head node `head`, return a middle node of the LinkedList
  - If two middle nodes, return the second

### Approach

Letâ€™s utilize the Runner Technique and use the following logic.

1. If the list is empty, do nothing!
2. Letâ€™s declare a slow and fast pointer both starting at head
3. For every iteration, move the slow pointer by one and the fast by two
4. When the fast pointer reaches the finish line, our slow pointer should have 5. arrived at the middle node!
5. Return the slow pointer

```python
def middleNode(head):
    if head == None or head.next == None:
        return head

    slow = head
    fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    return slow
```

## Singly LinkList

- Data
- Next

```python

class Node():
    def __init__(self, val, next=None):
        self.val = val
        self.next = next

head = Node(3, Node(2, Node(1, None)))
```

### Traversal

```python
def sum(head):
    total = 0

    current = head
    while current: # go until current is None
        total += current.val
        current = current.next # advance

    return total
```

### Adding a New Node (Middle)

1. Create a `new_node`
2. Make `new_node` point to the next node
3. Have the original `node.next` point to `new_node`

```python

```

### Removing A Node

1. Find the node _before_ the one you want to remove
2. Have its â€˜nextâ€™ point at the one _after_ the node you want to remove

```python
prev.next = prev.next.next
```

### Appending to the END

1. Find the last node
2. Assign the last node.next to the new_node

```python
def append(head, x)
    new_node = Node(x)

    if not head: # adding to an empty list
        return new_node

    current = head # doesn't modify the head
    while current.next:
        current = current.next

    current.next = new_node

    return head
```

### Popping from the END

```python
def pop(head, x)
    if not head: # removing to an empty list
        raise Exception('Cannot remove from an empty list!')

    if not head.next # only 1 element of the list
        return None

    current = head # doesn't modify the head
    while current.next:
        current = current.next

    current.next = new_node

    return head
```

## Doubly LinkList

- Data
- Next
- Prev

```

```
